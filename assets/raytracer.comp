#version 430

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D accumImage;

//-- Data --
vec2 resolution = imageSize(accumImage);
uniform vec3 cameraPos;
uniform vec3 cameraFront;
uniform vec3 cameraUp;

uniform uint sphereCount;

uniform uint frameIndex;

// -- Structs --

struct Material {
    vec3 color;
    float smoothness;
    vec4 emission; //rgb + strength
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 invDir;
};

struct Collision {
    uint didHit;
    float distance;
    vec3 hitPoint;
    vec3 normal;
    Material material;
};

struct Triangle {
    vec3 a;
    uint materialIdx;
    
    vec3 b;
    uint pad0;

    vec3 c;
    uint pad1;
};

struct Sphere {
    vec3 pos;
    float radius;
    Material material;
};

struct BVHNode {
    vec4 min;
    vec4 max;
    uint left;
    uint right;
    uint triangleCount; // 0 = interior, >0 = leaf
    uint pad;
};

// -- SSBOs --

struct SceneData {
    uint maxBounce;
    uint numRaysPerPixel;
};

layout(std430, binding = 0) buffer Spheres {
    Sphere spheres[];
};

layout(std430, binding = 1) buffer Materials {
    Material materials[];
};

layout(std430, binding = 2) buffer Triangles {
    Triangle triangles[];
};

layout(std430, binding = 3) buffer BVHNodes {
    BVHNode nodes[];
};

layout(std140, binding = 4) buffer Data {
    SceneData sceneData;
};

// shared BVHNode shNodes[8];

// -- Functions --

Collision raySphere(Ray ray, Sphere s){
    Collision collision;
    collision.didHit = 0;

    vec3 oc = s.pos - ray.origin;

    float closestApproach = dot(oc, ray.direction);
    if(closestApproach < 0) return collision; //sphere behind ray

    float distRay2 = dot(oc, oc) - closestApproach * closestApproach;
    float r2 = s.radius * s.radius;

    if(distRay2 > r2) return collision; //if distance to ray greater to radius, miss

    collision.distance = closestApproach - sqrt(r2 - distRay2); //closest - distance from closest to sphere surface
    collision.didHit = 1;
    collision.hitPoint = ray.origin + ray.direction * collision.distance;
    collision.normal = (collision.hitPoint - s.pos) / s.radius; // cheaper normal
    collision.material = s.material;
    return collision;
}

bool rayAABB(Ray ray, vec3 minB, vec3 maxB, float maxDist){
    vec3 t0 = (minB - ray.origin) * ray.invDir;
    vec3 t1 = (maxB - ray.origin) * ray.invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    return tFar >= max(tNear, 0.0) && tNear < maxDist;
}
// Moller-Trumbore algorithm
// https://en.wikipedia.org/wiki/Moller-Trumbore_intersection_algorithm
// adapted from https://stackoverflow.com/a/42752998
Collision rayTriangle(Ray ray, Triangle tri){
    Collision c;
    c.didHit = 0;

    vec3 edge1 = tri.b.xyz - tri.a.xyz;
    vec3 edge2 = tri.c.xyz - tri.a.xyz;
    vec3 normalVec = cross(edge1, edge2);
    float det = -dot(ray.direction, normalVec);
    if(det < 1E-6) return c;

    float invdet = 1.0f/det;
    vec3 ao = ray.origin - tri.a.xyz;
    vec3 dao = cross(ao, ray.direction);
    float u = dot(edge2, dao) * invdet;
    if(u < 0.0 || u > 1.0) return c;

    float v = -dot(edge1, dao) * invdet;
    if(v < 0.0 || u + v > 1.0) return c;

    float dist = dot(ao, normalVec) * invdet;
    if(dist < 0.0) return c;

    float w = 1 - u - v;

    c.didHit = (det>=1E-6 && dist >= 0 && u >= 0 && v >= 0 && w >= 0) ? 1 : 0;
    c.hitPoint = ray.origin + ray.direction * dist;
    c.normal = normalize(normalVec);
    c.distance = dist;
    c.material = materials[tri.materialIdx];

    return c;
}

Collision rayBVH(Ray ray){
    Collision closest;
    closest.didHit = 0;
    closest.distance = 1e30;

    uint stack[64];
    uint stackPtr = 0;
    stack[stackPtr++] = 0;

    while(stackPtr > 0){
        uint idx = stack[--stackPtr];
        BVHNode node = nodes[idx];

        if(!rayAABB(ray, node.min.xyz, node.max.xyz, closest.distance)) continue;

        if(node.triangleCount > 0){
            for(uint i = 0; i < node.triangleCount; i++){
                uint triangleIdx = node.left + i;
                Collision c = rayTriangle(ray, triangles[triangleIdx]);
                if(c.didHit == 1 && c.distance < closest.distance)
                    closest = c;
            }
        }else{
    BVHNode leftNode  = nodes[node.left];
    BVHNode rightNode = nodes[node.right];

    bool hitLeft  = rayAABB(ray, leftNode.min.xyz,  leftNode.max.xyz,  closest.distance);
    bool hitRight = rayAABB(ray, rightNode.min.xyz, rightNode.max.xyz, closest.distance);

    if(hitLeft && stackPtr < 64)
        stack[stackPtr++] = node.left;

    if(hitRight && stackPtr < 64)
        stack[stackPtr++] = node.right;
}
    }

    return closest;
}

Collision calculateRayCollision(Ray ray)
{
    Collision closest;
    closest.didHit = 0;
    closest.distance = 1e30; // very large distance as a default

    for(int i = 0; i < sphereCount; i++){
        Collision current = raySphere(ray, spheres[i]);

        if(current.didHit == 1 && current.distance < closest.distance)
            closest = current;
    }

    Collision triCollision = rayBVH(ray);
    if(triCollision.didHit == 1 && triCollision.distance < closest.distance)
        closest = triCollision;

    return closest;
}

float randomFloat(inout uint rng){
    rng = rng * 747796405u + 2891336453u;
    uint result = ((rng >> ((rng >> 28u) + 4u)) ^ rng) * 277803737u;
    result = (result >> 22u) ^ result;

    return float(result) / 4294967295.0;
}

// PCG rng
float randomNormalDistribution(inout uint rng){
    float u = randomFloat(rng);

    // normal dist
    float theta = 2 * 3.1415926 * u;
    float rho = sqrt(-2 * log(u));
    return rho * cos(theta);
}

vec3 cosineHemisphereDirection(vec3 normal, inout uint rng){ // removes diffuse bias
    float u1 = randomFloat(rng);
    float u2 = randomFloat(rng);

    float r = sqrt(u1);
    float theta = 2.0 * 3.1415926 * u2;

    vec3 tangent = normalize(abs(normal.x) > 0.1 ? cross(vec3(0,1,0), normal) : cross(vec3(1,0,0), normal));

    return normalize(
        r * cos(theta) * tangent + 
        r * sin(theta) * cross(normal, tangent) +
        sqrt(1.0 - u1) * normal
    );
}

vec3 ambient(Ray ray){
    // this can be over-complicated later
    return vec3(0.01);
}

vec3 trace(Ray ray, inout uint rng){
    vec3 incomingLight = vec3(0);
    vec3 rayColor = vec3(1.0f);

    for(int i=0; i <= sceneData.maxBounce; i++){
        Collision collision = calculateRayCollision(ray);

        if(collision.didHit == 0){
            incomingLight += ambient(ray);
            break;
        }
        ray.origin = collision.hitPoint + collision.normal * 0.0005;

        vec3 diffuseDir = cosineHemisphereDirection(collision.normal, rng);
        vec3 specularDir = reflect(ray.direction, collision.normal);

        ray.direction = normalize(mix(diffuseDir, specularDir, collision.material.smoothness));
        ray.invDir = 1.0 / ray.direction;  
        incomingLight += collision.material.emission.rgb * collision.material.emission.a * rayColor;

        rayColor *= collision.material.color.rgb;

        //russian roulette
        float p = max(rayColor.r, max(rayColor.g, rayColor.b));
        if (i > 3){
            p = clamp(p, 0.05, 0.95);

            if(randomFloat(rng) > p) break;

            rayColor /= p;
        }
    }

    return incomingLight;
}

uint hash(uint x) {
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
};

void main()
{
    // uint localIndex = gl_LocalInvocationIndex;
    // if(localIndex < 8) {
    //     shNodes[localIndex] = nodes[localIndex];
    // }

    // barrier();
    // memoryBarrierShared();

    uvec2 size = imageSize(accumImage);
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= uint(resolution.x) || pixel.y >= uint(resolution.y))
        return;

    vec2 uv = (vec2(pixel) + 0.5) / resolution;
    vec2 screen = uv - 0.5;
    screen.x *= resolution.x / resolution.y;

    uint rng = hash((pixel.y * uint(resolution.x) + pixel.x) ^ hash(frameIndex));

    vec3 forward = normalize(cameraFront);
    vec3 right   = normalize(cross(forward, cameraUp));
    vec3 up      = cross(right, forward);

    Ray ray;
    ray.origin = cameraPos;
    ray.direction = normalize(
        cameraPos +
        forward +
        screen.x * right +
        screen.y * up -
        cameraPos
    );
    ray.invDir = 1.0 / ray.direction;

    vec3 totalLight = vec3(0);
    for (int i = 0; i < int(sceneData.numRaysPerPixel); i++) {
        totalLight += trace(ray, rng);
    }
    totalLight /= sceneData.numRaysPerPixel;

    if (frameIndex == 0) {
        imageStore(accumImage, ivec2(pixel), vec4(totalLight, 1.0));
        return;
    }

    vec4 prev = imageLoad(accumImage, ivec2(pixel));
    float weight = 1.0 / (frameIndex + 1);

    vec3 color = mix(prev.rgb, totalLight, weight);
    imageStore(accumImage, ivec2(pixel), vec4(color, 1.0));
}
